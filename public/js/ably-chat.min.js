(function(m,J){typeof exports=="object"&&typeof module<"u"?J(exports,require("ably")):typeof define=="function"&&define.amd?define(["exports","ably"],J):(m=typeof globalThis<"u"?globalThis:m||self,J(m.AblyChat={},m.Ably))})(this,function(m,J){"use strict";function qt(n){const e=Object.create(null,{[Symbol.toStringTag]:{value:"Module"}});if(n){for(const t in n)if(t!=="default"){const r=Object.getOwnPropertyDescriptor(n,t);Object.defineProperty(e,t,r.get?r:{enumerable:!0,get:()=>n[t]})}}return e.default=n,Object.freeze(e)}const g=qt(J);var be=(n=>(n.Trace="trace",n.Debug="debug",n.Info="info",n.Warn="warn",n.Error="error",n.Silent="silent",n))(be||{});const kt=(n,e,t)=>{const r=t?`, context: ${JSON.stringify(t)}`:"",i=`[${new Date().toISOString()}] ${e.valueOf().toUpperCase()} ably-chat: ${n}${r}`;switch(e){case"trace":case"debug":{console.log(i);break}case"info":{console.info(i);break}case"warn":{console.warn(i);break}case"error":{console.error(i);break}}},zt=n=>{const e=n.logHandler??kt;return new we(e,n.logLevel)},Ue=new Map([["trace",0],["debug",1],["info",2],["warn",3],["error",4],["silent",5]]);class we{constructor(e,t,r){this._handler=e,this._context=r;const i=Ue.get(t);if(i===void 0)throw new g.ErrorInfo(`Invalid log level: ${t}`,5e4,500);this._levelNumber=i}trace(e,t){this._write(e,"trace",0,t)}debug(e,t){this._write(e,"debug",1,t)}info(e,t){this._write(e,"info",2,t)}warn(e,t){this._write(e,"warn",3,t)}error(e,t){this._write(e,"error",4,t)}withContext(e){const t=[...Ue.entries()].find(([,r])=>r===this._levelNumber)?.[0]??"error";return new we(this._handler,t,this._mergeContext(e))}_write(e,t,r,i){r>=this._levelNumber&&this._handler(e,t,this._mergeContext(i))}_mergeContext(e){return this._context?e?{...this._context,...e}:this._context:e??void 0}}const Bt={logLevel:be.Error},$t=n=>(n=n??{},{...n,logLevel:n.logLevel??Bt.logLevel});function k(n,e,t){if((Array.isArray(e)||typeof e=="string")&&t)return n.on(e,t),()=>{n.off(t)};if(typeof e=="function")return n.on(e),()=>{n.off(e)};throw new TypeError("Invalid arguments passed to on()")}function Ft(n,e,t){if(t)return n.once(e,t),()=>{n.off(t)};throw new TypeError("Invalid arguments passed to once()")}function z(n,e,t){if((Array.isArray(e)||typeof e=="string")&&t){const r=n.subscribe(e,t);return()=>{r.then(()=>{n.unsubscribe(t)}).catch(i=>{console.error("Error subscribing to events:",i)})}}else if(typeof e=="function"){const r=n.subscribe(e);return()=>{r.then(()=>{n.unsubscribe(e)}).catch(i=>{console.error("Error subscribing to events:",i)})}}else throw new TypeError("Invalid arguments passed to subscribe()")}const Ht=g.Realtime.EventEmitter;class C extends Ht{}const T=n=>(...e)=>n(...e),L=n=>{const e=n,t=Object.values(e.events).flat().length+e.any.length+Object.values(e.eventsOnce).flat().length+e.anyOnce.length;return t?t>0:!1};var qe=(n=>(n.Initialized="initialized",n.Connecting="connecting",n.Connected="connected",n.Disconnected="disconnected",n.Suspended="suspended",n.Failed="failed",n))(qe||{});class Gt{constructor(e,t){this._status="initialized",this._emitter=new C,this._logger=t,this._status=this._mapAblyStatusToChat(e.connection.state),this._error=e.connection.errorReason;const r=i=>{const c=this._mapAblyStatusToChat(i.current);if(c===this._status)return;const l={current:c,previous:this._status,error:i.reason,retryIn:i.retryIn};this._applyStatusChange(l)};this._clearAblyConnectionListener=k(e.connection,r)}get status(){return this._status}get error(){return this._error}onStatusChange(e){const t=T(e);return this._emitter.on(t),{off:()=>{this._emitter.off(t)}}}dispose(){this._logger.trace("DefaultConnection.dispose();"),this._clearAblyConnectionListener(),this._emitter.off()}hasListeners(){return L(this._emitter)}_applyStatusChange(e){this._status=e.current,this._error=e.error,this._logger.info("Connection state changed",e),this._emitter.emit(e.current,e)}_mapAblyStatusToChat(e){switch(e){case"closing":case"closed":return"failed";default:return e}}}const ke=()=>Math.random().toString(36).slice(2);var ze=Object.prototype.hasOwnProperty;function Be(n,e,t){for(t of n.keys())if(X(t,e))return t}function X(n,e){var t,r,i;if(n===e)return!0;if(n&&e&&(t=n.constructor)===e.constructor){if(t===Date)return n.getTime()===e.getTime();if(t===RegExp)return n.toString()===e.toString();if(t===Array){if((r=n.length)===e.length)for(;r--&&X(n[r],e[r]););return r===-1}if(t===Set){if(n.size!==e.size)return!1;for(r of n)if(i=r,i&&typeof i=="object"&&(i=Be(e,i),!i)||!e.has(i))return!1;return!0}if(t===Map){if(n.size!==e.size)return!1;for(r of n)if(i=r[0],i&&typeof i=="object"&&(i=Be(e,i),!i)||!X(r[1],e.get(i)))return!1;return!0}if(t===ArrayBuffer)n=new Uint8Array(n),e=new Uint8Array(e);else if(t===DataView){if((r=n.byteLength)===e.byteLength)for(;r--&&n.getInt8(r)===e.getInt8(r););return r===-1}if(ArrayBuffer.isView(n)){if((r=n.byteLength)===e.byteLength)for(;r--&&n[r]===e[r];);return r===-1}if(!t||typeof n=="object"){r=0;for(t in n)if(ze.call(n,t)&&++r&&!ze.call(e,t)||!(t in e)||!X(n[t],e[t]))return!1;return Object.keys(e).length===r}}return n!==n&&e!==e}var E=(n=>(n.Created="message.created",n.Updated="message.updated",n.Deleted="message.deleted",n))(E||{}),$e=(n=>(n.ChatMessage="chat.message",n))($e||{}),Fe=(n=>(n.Occupancy="[meta]occupancy",n))(Fe||{}),R=(n=>(n.MessageCreate="message.create",n.MessageUpdate="message.update",n.MessageDelete="message.delete",n.MessageAnnotationSummary="message.summary",n.MessageMetaOccupancy="meta.occupancy",n))(R||{}),He=(n=>(n.Enter="enter",n.Leave="leave",n.Update="update",n.Present="present",n))(He||{}),M=(n=>(n.Started="typing.started",n.Stopped="typing.stopped",n))(M||{}),P=(n=>(n.SetChanged="typing.set.changed",n))(P||{}),Se=(n=>(n.Reaction="roomReaction",n))(Se||{}),ve=(n=>(n.Reaction="reaction",n))(ve||{}),x=(n=>(n.Unique="unique",n.Distinct="distinct",n.Multiple="multiple",n))(x||{}),se=(n=>(n.Unique="reaction:unique.v1",n.Distinct="reaction:distinct.v1",n.Multiple="reaction:multiple.v1",n))(se||{});const Vt={"reaction:unique.v1":"unique","reaction:distinct.v1":"distinct","reaction:multiple.v1":"multiple"};var A=(n=>(n.Create="reaction.create",n.Delete="reaction.delete",n.Summary="reaction.summary",n))(A||{}),ne=(n=>(n.Updated="occupancy.updated",n))(ne||{}),H=(n=>(n.Discontinuity="room.discontinuity",n))(H||{}),re=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function Wt(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}var Y={exports:{}};Y.exports;var Ge;function Kt(){return Ge||(Ge=1,function(n,e){var t=200,r="__lodash_hash_undefined__",i=9007199254740991,c="[object Arguments]",l="[object Array]",u="[object Boolean]",_="[object Date]",y="[object Error]",d="[object Function]",w="[object GeneratorFunction]",G="[object Map]",le="[object Number]",Te="[object Object]",Ze="[object Promise]",et="[object RegExp]",ue="[object Set]",tt="[object String]",st="[object Symbol]",Me="[object WeakMap]",nt="[object ArrayBuffer]",ge="[object DataView]",rt="[object Float32Array]",it="[object Float64Array]",at="[object Int8Array]",ot="[object Int16Array]",ct="[object Int32Array]",ht="[object Uint8Array]",lt="[object Uint8ClampedArray]",ut="[object Uint16Array]",gt="[object Uint32Array]",Ds=/[\\^$.*+?()[\]{}|]/g,Ls=/\w*$/,Ps=/^\[object .+?Constructor\]$/,xs=/^(?:0|[1-9]\d*)$/,f={};f[c]=f[l]=f[nt]=f[ge]=f[u]=f[_]=f[rt]=f[it]=f[at]=f[ot]=f[ct]=f[G]=f[le]=f[Te]=f[et]=f[ue]=f[tt]=f[st]=f[ht]=f[lt]=f[ut]=f[gt]=!0,f[y]=f[d]=f[Me]=!1;var Ns=typeof re=="object"&&re&&re.Object===Object&&re,js=typeof self=="object"&&self&&self.Object===Object&&self,I=Ns||js||Function("return this")(),dt=e&&!e.nodeType&&e,_t=dt&&!0&&n&&!n.nodeType&&n,Us=_t&&_t.exports===dt;function qs(s,a){return s.set(a[0],a[1]),s}function ks(s,a){return s.add(a),s}function zs(s,a){for(var o=-1,h=s?s.length:0;++o<h&&a(s[o],o,s)!==!1;);return s}function Bs(s,a){for(var o=-1,h=a.length,b=s.length;++o<h;)s[b+o]=a[o];return s}function ft(s,a,o,h){for(var b=-1,S=s?s.length:0;++b<S;)o=a(o,s[b],b,s);return o}function $s(s,a){for(var o=-1,h=Array(s);++o<s;)h[o]=a(o);return h}function Fs(s,a){return s?.[a]}function pt(s){var a=!1;if(s!=null&&typeof s.toString!="function")try{a=!!(s+"")}catch{}return a}function mt(s){var a=-1,o=Array(s.size);return s.forEach(function(h,b){o[++a]=[b,h]}),o}function Ae(s,a){return function(o){return s(a(o))}}function yt(s){var a=-1,o=Array(s.size);return s.forEach(function(h){o[++a]=h}),o}var Hs=Array.prototype,Gs=Function.prototype,de=Object.prototype,Ce=I["__core-js_shared__"],bt=function(){var s=/[^.]+$/.exec(Ce&&Ce.keys&&Ce.keys.IE_PROTO||"");return s?"Symbol(src)_1."+s:""}(),wt=Gs.toString,q=de.hasOwnProperty,_e=de.toString,Vs=RegExp("^"+wt.call(q).replace(Ds,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),St=Us?I.Buffer:void 0,vt=I.Symbol,Rt=I.Uint8Array,Ws=Ae(Object.getPrototypeOf,Object),Ks=Object.create,Qs=de.propertyIsEnumerable,Js=Hs.splice,Tt=Object.getOwnPropertySymbols,Xs=St?St.isBuffer:void 0,Ys=Ae(Object.keys,Object),Ee=K(I,"DataView"),ee=K(I,"Map"),Ie=K(I,"Promise"),Oe=K(I,"Set"),De=K(I,"WeakMap"),te=K(Object,"create"),Zs=F(Ee),en=F(ee),tn=F(Ie),sn=F(Oe),nn=F(De),Mt=vt?vt.prototype:void 0,At=Mt?Mt.valueOf:void 0;function B(s){var a=-1,o=s?s.length:0;for(this.clear();++a<o;){var h=s[a];this.set(h[0],h[1])}}function rn(){this.__data__=te?te(null):{}}function an(s){return this.has(s)&&delete this.__data__[s]}function on(s){var a=this.__data__;if(te){var o=a[s];return o===r?void 0:o}return q.call(a,s)?a[s]:void 0}function cn(s){var a=this.__data__;return te?a[s]!==void 0:q.call(a,s)}function hn(s,a){var o=this.__data__;return o[s]=te&&a===void 0?r:a,this}B.prototype.clear=rn,B.prototype.delete=an,B.prototype.get=on,B.prototype.has=cn,B.prototype.set=hn;function O(s){var a=-1,o=s?s.length:0;for(this.clear();++a<o;){var h=s[a];this.set(h[0],h[1])}}function ln(){this.__data__=[]}function un(s){var a=this.__data__,o=fe(a,s);if(o<0)return!1;var h=a.length-1;return o==h?a.pop():Js.call(a,o,1),!0}function gn(s){var a=this.__data__,o=fe(a,s);return o<0?void 0:a[o][1]}function dn(s){return fe(this.__data__,s)>-1}function _n(s,a){var o=this.__data__,h=fe(o,s);return h<0?o.push([s,a]):o[h][1]=a,this}O.prototype.clear=ln,O.prototype.delete=un,O.prototype.get=gn,O.prototype.has=dn,O.prototype.set=_n;function V(s){var a=-1,o=s?s.length:0;for(this.clear();++a<o;){var h=s[a];this.set(h[0],h[1])}}function fn(){this.__data__={hash:new B,map:new(ee||O),string:new B}}function pn(s){return pe(this,s).delete(s)}function mn(s){return pe(this,s).get(s)}function yn(s){return pe(this,s).has(s)}function bn(s,a){return pe(this,s).set(s,a),this}V.prototype.clear=fn,V.prototype.delete=pn,V.prototype.get=mn,V.prototype.has=yn,V.prototype.set=bn;function W(s){this.__data__=new O(s)}function wn(){this.__data__=new O}function Sn(s){return this.__data__.delete(s)}function vn(s){return this.__data__.get(s)}function Rn(s){return this.__data__.has(s)}function Tn(s,a){var o=this.__data__;if(o instanceof O){var h=o.__data__;if(!ee||h.length<t-1)return h.push([s,a]),this;o=this.__data__=new V(h)}return o.set(s,a),this}W.prototype.clear=wn,W.prototype.delete=Sn,W.prototype.get=vn,W.prototype.has=Rn,W.prototype.set=Tn;function Mn(s,a){var o=xe(s)||Qn(s)?$s(s.length,String):[],h=o.length,b=!!h;for(var S in s)q.call(s,S)&&!(b&&(S=="length"||Gn(S,h)))&&o.push(S);return o}function Ct(s,a,o){var h=s[a];(!(q.call(s,a)&&Dt(h,o))||o===void 0&&!(a in s))&&(s[a]=o)}function fe(s,a){for(var o=s.length;o--;)if(Dt(s[o][0],a))return o;return-1}function An(s,a){return s&&Et(a,Ne(a),s)}function Le(s,a,o,h,b,S,D){var v;if(h&&(v=S?h(s,b,S,D):h(s)),v!==void 0)return v;if(!me(s))return s;var xt=xe(s);if(xt){if(v=$n(s),!a)return kn(s,v)}else{var Q=$(s),Nt=Q==d||Q==w;if(Xn(s))return Ln(s,a);if(Q==Te||Q==c||Nt&&!S){if(pt(s))return S?s:{};if(v=Fn(Nt?{}:s),!a)return zn(s,An(v,s))}else{if(!f[Q])return S?s:{};v=Hn(s,Q,Le,a)}}D||(D=new W);var jt=D.get(s);if(jt)return jt;if(D.set(s,v),!xt)var Ut=o?Bn(s):Ne(s);return zs(Ut||s,function(je,ye){Ut&&(ye=je,je=s[ye]),Ct(v,ye,Le(je,a,o,h,ye,s,D))}),v}function Cn(s){return me(s)?Ks(s):{}}function En(s,a,o){var h=a(s);return xe(s)?h:Bs(h,o(s))}function In(s){return _e.call(s)}function On(s){if(!me(s)||Wn(s))return!1;var a=Pt(s)||pt(s)?Vs:Ps;return a.test(F(s))}function Dn(s){if(!Ot(s))return Ys(s);var a=[];for(var o in Object(s))q.call(s,o)&&o!="constructor"&&a.push(o);return a}function Ln(s,a){if(a)return s.slice();var o=new s.constructor(s.length);return s.copy(o),o}function Pe(s){var a=new s.constructor(s.byteLength);return new Rt(a).set(new Rt(s)),a}function Pn(s,a){var o=a?Pe(s.buffer):s.buffer;return new s.constructor(o,s.byteOffset,s.byteLength)}function xn(s,a,o){var h=a?o(mt(s),!0):mt(s);return ft(h,qs,new s.constructor)}function Nn(s){var a=new s.constructor(s.source,Ls.exec(s));return a.lastIndex=s.lastIndex,a}function jn(s,a,o){var h=a?o(yt(s),!0):yt(s);return ft(h,ks,new s.constructor)}function Un(s){return At?Object(At.call(s)):{}}function qn(s,a){var o=a?Pe(s.buffer):s.buffer;return new s.constructor(o,s.byteOffset,s.length)}function kn(s,a){var o=-1,h=s.length;for(a||(a=Array(h));++o<h;)a[o]=s[o];return a}function Et(s,a,o,h){o||(o={});for(var b=-1,S=a.length;++b<S;){var D=a[b],v=void 0;Ct(o,D,v===void 0?s[D]:v)}return o}function zn(s,a){return Et(s,It(s),a)}function Bn(s){return En(s,Ne,It)}function pe(s,a){var o=s.__data__;return Vn(a)?o[typeof a=="string"?"string":"hash"]:o.map}function K(s,a){var o=Fs(s,a);return On(o)?o:void 0}var It=Tt?Ae(Tt,Object):er,$=In;(Ee&&$(new Ee(new ArrayBuffer(1)))!=ge||ee&&$(new ee)!=G||Ie&&$(Ie.resolve())!=Ze||Oe&&$(new Oe)!=ue||De&&$(new De)!=Me)&&($=function(s){var a=_e.call(s),o=a==Te?s.constructor:void 0,h=o?F(o):void 0;if(h)switch(h){case Zs:return ge;case en:return G;case tn:return Ze;case sn:return ue;case nn:return Me}return a});function $n(s){var a=s.length,o=s.constructor(a);return a&&typeof s[0]=="string"&&q.call(s,"index")&&(o.index=s.index,o.input=s.input),o}function Fn(s){return typeof s.constructor=="function"&&!Ot(s)?Cn(Ws(s)):{}}function Hn(s,a,o,h){var b=s.constructor;switch(a){case nt:return Pe(s);case u:case _:return new b(+s);case ge:return Pn(s,h);case rt:case it:case at:case ot:case ct:case ht:case lt:case ut:case gt:return qn(s,h);case G:return xn(s,h,o);case le:case tt:return new b(s);case et:return Nn(s);case ue:return jn(s,h,o);case st:return Un(s)}}function Gn(s,a){return a=a??i,!!a&&(typeof s=="number"||xs.test(s))&&s>-1&&s%1==0&&s<a}function Vn(s){var a=typeof s;return a=="string"||a=="number"||a=="symbol"||a=="boolean"?s!=="__proto__":s===null}function Wn(s){return!!bt&&bt in s}function Ot(s){var a=s&&s.constructor,o=typeof a=="function"&&a.prototype||de;return s===o}function F(s){if(s!=null){try{return wt.call(s)}catch{}try{return s+""}catch{}}return""}function Kn(s){return Le(s,!0,!0)}function Dt(s,a){return s===a||s!==s&&a!==a}function Qn(s){return Jn(s)&&q.call(s,"callee")&&(!Qs.call(s,"callee")||_e.call(s)==c)}var xe=Array.isArray;function Lt(s){return s!=null&&Yn(s.length)&&!Pt(s)}function Jn(s){return Zn(s)&&Lt(s)}var Xn=Xs||tr;function Pt(s){var a=me(s)?_e.call(s):"";return a==d||a==w}function Yn(s){return typeof s=="number"&&s>-1&&s%1==0&&s<=i}function me(s){var a=typeof s;return!!s&&(a=="object"||a=="function")}function Zn(s){return!!s&&typeof s=="object"}function Ne(s){return Lt(s)?Mn(s):Dn(s)}function er(){return[]}function tr(){return!1}n.exports=Kn}(Y,Y.exports)),Y.exports}var Qt=Kt();const N=Wt(Qt);class j{constructor({serial:e,clientId:t,text:r,metadata:i,headers:c,action:l,version:u,createdAt:_,timestamp:y,reactions:d,operation:w}){this.serial=e,this.clientId=t,this.text=r,this.metadata=i,this.headers=c,this.action=l,this.version=u,this.createdAt=_,this.timestamp=y,this.reactions=d,this.operation=w,Object.freeze(this.reactions),Object.freeze(this.reactions.multiple),Object.freeze(this.reactions.distinct),Object.freeze(this.reactions.unique),Object.freeze(this)}get isUpdated(){return this.action===R.MessageUpdate}get isDeleted(){return this.action===R.MessageDelete}get updatedBy(){return this.isUpdated?this.operation?.clientId:void 0}get deletedBy(){return this.isDeleted?this.operation?.clientId:void 0}get updatedAt(){return this.isUpdated?this.timestamp:void 0}get deletedAt(){return this.isDeleted?this.timestamp:void 0}isOlderVersionOf(e){return this.equal(e)?this.version<e.version:!1}isNewerVersionOf(e){return this.equal(e)?this.version>e.version:!1}isSameVersionAs(e){return this.equal(e)?this.version===e.version:!1}before(e){return this.serial<e.serial}after(e){return this.serial>e.serial}equal(e){return this.serial===e.serial}isSameAs(e){return this.equal(e)}with(e){if("serial"in e)return this._getLatestMessageVersion(e);if(e.type===E.Created)throw new g.ErrorInfo("cannot apply a created event to a message",4e4,400);if(e.type===A.Summary){if(e.summary.messageSerial!==this.serial)throw new g.ErrorInfo("cannot apply event for a different message",4e4,400);const t={unique:N(e.summary.unique),distinct:N(e.summary.distinct),multiple:N(e.summary.multiple)};return j._clone(this,{reactions:t})}return this._getLatestMessageVersion(e.message)}_getLatestMessageVersion(e){if(e.serial!==this.serial)throw new g.ErrorInfo("cannot apply event for a different message",4e4,400);return this.version>=e.version?this:j._clone(e,{reactions:this.reactions})}static _clone(e,t){return new j({serial:t?.serial??e.serial,clientId:t?.clientId??e.clientId,text:t?.text??e.text,metadata:t?.metadata??N(e.metadata),headers:t?.headers??N(e.headers),action:t?.action??e.action,version:t?.version??e.version,createdAt:t?.createdAt??e.createdAt,timestamp:t?.timestamp??e.timestamp,reactions:t?.reactions??N(e.reactions),operation:t?.operation??N(e.operation)})}copy(e={}){return j._clone(this,e)}}const Re=()=>({unique:{},distinct:{},multiple:{}}),Jt=n=>{const e=n,t=e.data&&typeof e.data=="object"?e.data:{},r=e.extras&&typeof e.extras=="object"?e.extras:{},i=e.clientId||"",c=t.text||"",l=e.serial||"",u=e.version||"",_=t.metadata&&typeof t.metadata=="object"?t.metadata:{},y=r.headers||{},d=Date.now(),w=new Date(e.createdAt||d),G=new Date(e.timestamp||d),le=Object.values(R).includes(e.action)?e.action:R.MessageCreate;return new j({serial:l,clientId:i,text:c,metadata:_,headers:y,action:le,version:u,createdAt:w,timestamp:G,reactions:Re(),operation:e.operation})},Z=n=>{let e="";if(typeof n=="string")e=n;else try{"serial"in n&&(e=n.serial)}catch{}if(e==="")throw new g.ErrorInfo("invalid serial; must be string or object with serial property",4e4,400);return e},Xt={"annotation.create":A.Create,"annotation.delete":A.Delete};class Ve{constructor(e,t,r,i,c){this._logger=e,this._options=t,this._api=r,this._roomName=i,this._channel=c,this._emitter=new C,this._unsubscribeMessageEvents=z(c,this._processMessageEvent.bind(this)),this._options?.rawMessageReactions&&(this._unsubscribeAnnotationEvents=z(c.annotations,this._processAnnotationEvent.bind(this))),this._defaultType=this._options?.defaultMessageReactionType??x.Distinct}_processAnnotationEvent(e){this._logger.trace("MessagesReactions._processAnnotationEvent();",{event:e});const t=Vt[e.type];if(!t){this._logger.info("MessagesReactions._processAnnotationEvent(); ignoring unknown reaction type",{event:e});return}const r=Xt[e.action];if(!r){this._logger.info("MessagesReactions._processAnnotationEvent(); ignoring unknown reaction event type",{event:e});return}const i=e.name??"",c={type:r,timestamp:new Date(e.timestamp),reaction:{messageSerial:e.messageSerial,type:t,name:i,clientId:e.clientId??""}};e.count?c.reaction.count=e.count:r===A.Create&&t===x.Multiple&&(c.reaction.count=1),this._emitter.emit(r,c)}_processMessageEvent(e){if(this._logger.trace("MessagesReactions._processMessageEvent();",{event:e}),e.action!==R.MessageAnnotationSummary)return;e.summary||(e.summary={});const t=e.summary[se.Unique]??{},r=e.summary[se.Distinct]??{},i=e.summary[se.Multiple]??{};this._emitter.emit(A.Summary,{type:A.Summary,summary:{messageSerial:e.serial,unique:t,distinct:r,multiple:i}})}send(e,t){this._logger.trace("MessagesReactions.send();",{messageSerial:e,params:t});const r=Z(e);let{type:i,count:c}=t;i||(i=this._defaultType),i===x.Multiple&&!c&&(c=1);const l={type:i,name:t.name};return c&&(l.count=c),this._api.sendMessageReaction(this._roomName,r,l)}delete(e,t){this._logger.trace("MessagesReactions.delete();",{messageSerial:e,params:t});const r=Z(e);let i=t?.type;if(i||(i=this._defaultType),i!==x.Unique&&!t?.name)throw new g.ErrorInfo(`cannot delete reaction of type ${i} without a name`,40001,400);const c={type:i};return i!==x.Unique&&(c.name=t?.name),this._api.deleteMessageReaction(this._roomName,r,c)}subscribe(e){this._logger.trace("MessagesReactions.subscribe();");const t=T(e);return this._emitter.on(A.Summary,t),{unsubscribe:()=>{this._emitter.off(t)}}}subscribeRaw(e){if(this._logger.trace("MessagesReactions.subscribeRaw();"),!this._options?.rawMessageReactions)throw new g.ErrorInfo("Raw message reactions are not enabled",40001,400);const t=T(e);return this._emitter.on([A.Create,A.Delete],t),{unsubscribe:()=>{this._emitter.off(t)}}}static channelOptionMerger(e){return t=>(t.modes.includes("ANNOTATION_PUBLISH")||t.modes.push("ANNOTATION_PUBLISH"),e.messages.rawMessageReactions&&!t.modes.includes("ANNOTATION_SUBSCRIBE")&&t.modes.push("ANNOTATION_SUBSCRIBE"),t)}dispose(){this._logger.trace("DefaultMessageReactions.dispose();"),this._emitter.off(),this._unsubscribeMessageEvents(),this._unsubscribeAnnotationEvents?.(),this._logger.debug("DefaultMessageReactions.dispose(); disposed successfully")}hasListeners(){return L(this._emitter)}}const ie=n=>{const e={...Re(),...n.reactions},t=Object.values(R).includes(n.action)?n.action:R.MessageCreate;return new j({...n,action:t,createdAt:new Date(n.createdAt),timestamp:new Date(n.timestamp),reactions:e})},Yt=new Map([[R.MessageCreate,E.Created],[R.MessageUpdate,E.Updated],[R.MessageDelete,E.Deleted]]);var ae=(n=>(n.OldestFirst="oldestFirst",n.NewestFirst="newestFirst",n))(ae||{});class Zt{constructor(e,t,r,i,c,l){this._pendingPromiseRejecters=new Set,this._pendingAttachListeners=new Set,this._emitter=new C,this._roomName=e,this._options=t,this._channel=r,this._chatApi=i,this._clientId=c,this._logger=l,this._listenerSubscriptionPoints=new Map,this._reactions=new Ve(this._logger,t,this._chatApi,this._roomName,this._channel);const u=this._processEvent.bind(this),_=d=>{this._handleAttach(d.resumed)},y=d=>{d.current==="attached"&&d.previous==="attached"&&this._handleAttach(d.resumed)};this._unsubscribeMessageEvents=z(this._channel,[$e.ChatMessage],u),this._offChannelAttached=k(this._channel,"attached",_),this._offChannelUpdate=k(this._channel,"update",y)}get reactions(){return this._reactions}async _getBeforeSubscriptionStart(e,t){this._logger.trace("DefaultSubscriptionManager.getBeforeSubscriptionStart();");const r=this._listenerSubscriptionPoints.get(e);if(r===void 0)throw this._logger.error("DefaultSubscriptionManager.getBeforeSubscriptionStart(); listener has not been subscribed yet"),new g.ErrorInfo("cannot query history; listener has not been subscribed yet",4e4,400);const i=await r;return this._chatApi.history(this._roomName,{...t,orderBy:"newestFirst",...i})}_handleAttach(e){if(this._logger.trace("DefaultSubscriptionManager.handleAttach();"),e)return;const t=this._subscribeAtChannelAttach();for(const[r]of this._listenerSubscriptionPoints.entries())this._listenerSubscriptionPoints.set(r,t)}async _resolveSubscriptionStart(){const e=this._getChannelProperties();if(e.state==="attached"){if(e.properties.channelSerial)return{fromSerial:e.properties.channelSerial};throw this._logger.error("DefaultSubscriptionManager.handleAttach(); channelSerial is undefined"),new g.ErrorInfo("channel is attached, but channelSerial is not defined",4e4,400)}return this._subscribeAtChannelAttach()}_getChannelProperties(){return this._channel}async _subscribeAtChannelAttach(){const e=this._getChannelProperties();return new Promise((t,r)=>{this._pendingPromiseRejecters.add(r);const i=()=>{this._pendingPromiseRejecters.delete(r)};if(e.state==="attached"){this._logger.debug("Messages._subscribeAtChannelAttach(); channel is attached already, using attachSerial",{attachSerial:e.properties.attachSerial}),i(),e.properties.attachSerial?t({fromSerial:e.properties.attachSerial}):(this._logger.error("DefaultSubscriptionManager.handleAttach(); attachSerial is undefined"),i(),r(new g.ErrorInfo("channel is attached, but attachSerial is not defined",4e4,400)));return}const c=Ft(e,"attached",()=>{this._logger.debug("Messages._subscribeAtChannelAttach(); channel is now attached, using attachSerial",{attachSerial:e.properties.attachSerial}),i(),this._pendingAttachListeners.delete(c),e.properties.attachSerial?t({fromSerial:e.properties.attachSerial}):(this._logger.error("DefaultSubscriptionManager.handleAttach(); attachSerial is undefined"),r(new g.ErrorInfo("channel is attached, but attachSerial is not defined",4e4,400)))});this._pendingAttachListeners.add(c)})}async history(e){return this._logger.trace("Messages.query();"),this._chatApi.history(this._roomName,e)}get(e){return this._logger.trace("Messages.get();",{serial:e}),this._chatApi.getMessage(this._roomName,Z(e))}async send(e){this._logger.trace("Messages.send();",{params:e});const{text:t,metadata:r,headers:i}=e,c=await this._chatApi.sendMessage(this._roomName,{text:t,headers:i,metadata:r});return new j({serial:c.serial,clientId:this._clientId,text:t,metadata:r??{},headers:i??{},action:R.MessageCreate,version:c.serial,createdAt:new Date(c.createdAt),timestamp:new Date(c.createdAt),reactions:Re()})}async delete(e,t){this._logger.trace("Messages.delete();",{params:t}),e=Z(e),this._logger.debug("Messages.delete(); serial",{serial:e});const r=await this._chatApi.deleteMessage(this._roomName,e,t);return ie(r.message)}async update(e,t,r){this._logger.trace("Messages.update();",{updateParams:t,details:r}),e=Z(e),this._logger.debug("Messages.update(); serial",{serial:e});const i=await this._chatApi.updateMessage(this._roomName,e,{message:{text:t.text,metadata:t.metadata,headers:t.headers},...r});return this._logger.debug("Messages.update(); message update successfully",{updateParams:t}),ie(i.message)}subscribe(e){this._logger.trace("Messages.subscribe();");const t=T(e);this._emitter.on([E.Created,E.Updated,E.Deleted],t);const r=this._resolveSubscriptionStart();return r.catch(()=>{this._logger.debug("Messages.subscribe(); subscription point was not resolved before the room was released")}),this._listenerSubscriptionPoints.set(t,r),{unsubscribe:()=>{this._listenerSubscriptionPoints.delete(t),this._logger.trace("Messages.unsubscribe();"),this._emitter.off(t)},historyBeforeSubscribe:i=>this._getBeforeSubscriptionStart(t,i)}}_processEvent(e){this._logger.trace("Messages._processEvent();",{channelEventMessage:e});const{action:t}=e,r=Yt.get(t);if(!r){this._logger.debug("Messages._processEvent(); received unknown message action",{action:t});return}const i=Jt(e);this._emitter.emit(r,{type:r,message:i})}dispose(){this._logger.trace("DefaultMessages.dispose();"),this._emitter.off();const e=new g.ErrorInfo("room has been disposed",4e4,400);for(const t of this._pendingPromiseRejecters)try{t(e)}catch{}this._pendingPromiseRejecters.clear(),this._listenerSubscriptionPoints.clear();for(const t of this._pendingAttachListeners)t();this._pendingAttachListeners.clear(),this._unsubscribeMessageEvents(),this._offChannelAttached(),this._offChannelUpdate(),this._reactions.dispose(),this._logger.debug("DefaultMessages.dispose(); disposed successfully")}hasListeners(){return L(this._emitter)}}class es{constructor(e,t){this._apiProtocolVersion=3,this._realtime=e,this._logger=t}async history(e,t){e=encodeURIComponent(e);const r={...t};if(t.orderBy)switch(t.orderBy){case ae.NewestFirst:{r.direction="backwards";break}case ae.OldestFirst:{r.direction="forwards";break}default:throw new g.ErrorInfo(`invalid orderBy value: ${t.orderBy}`,4e4,400)}const i=await this._makeAuthorizedPaginatedRequest(`/chat/v3/rooms/${e}/messages`,r);return this._recursivePaginateMessages(i)}_recursivePaginateMessages(e){const t={};return t.items=e.items.map(r=>ie(r)),t.next=()=>e.next().then(r=>r?this._recursivePaginateMessages(r):null),t.first=()=>e.first().then(r=>this._recursivePaginateMessages(r)),t.current=()=>e.current().then(r=>this._recursivePaginateMessages(r)),t.hasNext=()=>e.hasNext(),t.isLast=()=>e.isLast(),{...e,...t}}async getMessage(e,t){const r=encodeURIComponent(t);e=encodeURIComponent(e);const i=await this._makeAuthorizedRequest(`/chat/v3/rooms/${e}/messages/${r}`,"GET");return ie(i)}deleteMessage(e,t,r){const i={description:r?.description,metadata:r?.metadata};return t=encodeURIComponent(t),e=encodeURIComponent(e),this._makeAuthorizedRequest(`/chat/v3/rooms/${e}/messages/${t}/delete`,"POST",i,{})}sendMessage(e,t){const r={text:t.text};return t.metadata&&(r.metadata=t.metadata),t.headers&&(r.headers=t.headers),e=encodeURIComponent(e),this._makeAuthorizedRequest(`/chat/v3/rooms/${e}/messages`,"POST",r)}updateMessage(e,t,r){const i=encodeURIComponent(t);return e=encodeURIComponent(e),this._makeAuthorizedRequest(`/chat/v3/rooms/${e}/messages/${i}`,"PUT",r)}sendMessageReaction(e,t,r){const i=encodeURIComponent(t);return e=encodeURIComponent(e),this._makeAuthorizedRequest(`/chat/v3/rooms/${e}/messages/${i}/reactions`,"POST",r)}deleteMessageReaction(e,t,r){const i=encodeURIComponent(t);return e=encodeURIComponent(e),this._makeAuthorizedRequest(`/chat/v3/rooms/${e}/messages/${i}/reactions`,"DELETE",void 0,r)}getOccupancy(e){return e=encodeURIComponent(e),this._makeAuthorizedRequest(`/chat/v3/rooms/${e}/occupancy`,"GET")}async _makeAuthorizedRequest(e,t,r,i){const c=await this._realtime.request(t,e,this._apiProtocolVersion,i,r);if(!c.success)throw this._logger.error("ChatApi._makeAuthorizedRequest(); failed to make request",{url:e,statusCode:c.statusCode,errorCode:c.errorCode,errorMessage:c.errorMessage}),new g.ErrorInfo(c.errorMessage,c.errorCode,c.statusCode);return c.items[0]}async _makeAuthorizedPaginatedRequest(e,t,r){const i=await this._realtime.request("GET",e,this._apiProtocolVersion,t,r);if(!i.success)throw this._logger.error("ChatApi._makeAuthorizedPaginatedRequest(); failed to make request",{url:e,statusCode:i.statusCode,errorCode:i.errorCode,errorMessage:i.errorMessage}),new g.ErrorInfo(i.errorMessage,i.errorCode,i.statusCode);return i}}var U=(n=>(n[n.BadRequest=4e4]="BadRequest",n[n.MessageRejectedByBeforePublishRule=42211]="MessageRejectedByBeforePublishRule",n[n.MessageRejectedByModeration=42213]="MessageRejectedByModeration",n[n.PresenceAutoReentryFailed=91004]="PresenceAutoReentryFailed",n[n.RoomDiscontinuity=102100]="RoomDiscontinuity",n[n.RoomInFailedState=102101]="RoomInFailedState",n[n.RoomIsReleasing=102102]="RoomIsReleasing",n[n.RoomIsReleased=102103]="RoomIsReleased",n[n.RoomReleasedBeforeOperationCompleted=102106]="RoomReleasedBeforeOperationCompleted",n))(U||{});const ts=(n,e)=>n.code===e,ss=n=>`${n}::$chat`,oe="0.12.0",ns=`chat-js/${oe}`,rs=`chat-react/${oe}`,We=["PUBLISH","SUBSCRIBE"],is={params:{agent:ns},attachOnSubscribe:!1,modes:We},as={params:{agent:rs},attachOnSubscribe:!1,modes:We};class os{constructor(e,t,r,i){r.trace("ChannelManager();",{isReact:i}),this._realtime=t,this._logger=r,this._isReact=i,this._registeredOptions=this._defaultChannelOptions(),this._channelId=ss(e)}mergeOptions(e){if(this._logger.trace("ChannelManager.mergeOptions();"),this._resolvedChannel)throw this._logger.error("channel options cannot be modified after the channel has been requested"),new g.ErrorInfo("channel options cannot be modified after the channel has been requested",4e4,400);this._registeredOptions=e(this._registeredOptions)}get(){return this._logger.trace("ChannelManager.get();"),this._resolvedChannel??=this._realtime.channels.get(this._channelId,this._registeredOptions),this._resolvedChannel}release(){this._logger.trace("ChannelManager.release();",{channelId:this._channelId}),this._resolvedChannel&&this._realtime.channels.release(this._channelId)}_defaultChannelOptions(){this._logger.trace("ChannelManager._defaultChannelOptions();");const e=this._isReact?as:is;return this._logger.trace(this._isReact?"using react channel options":"using default channel options"),{...e,modes:[...e.modes??[]]}}}const cs=n=>{const e=n;let t=0,r=0;if(!e.data||typeof e.data!="object")return{connections:t,presenceMembers:r};const{metrics:i}=e.data;return!i||typeof i!="object"?{connections:t,presenceMembers:r}:(typeof i.connections=="number"&&Number.isInteger(i.connections)&&(t=i.connections),typeof i.presenceMembers=="number"&&Number.isInteger(i.presenceMembers)&&(r=i.presenceMembers),{connections:t,presenceMembers:r})};class Ke{constructor(e,t,r,i,c){this._emitter=new C,this._roomName=e,this._channel=t,this._chatApi=r,this._logger=i,this._roomOptions=c;const l=this._internalOccupancyListener.bind(this);this._roomOptions.occupancy.enableEvents?(this._logger.debug("DefaultOccupancy(); subscribing to occupancy events"),this._unsubscribeOccupancyEvents=z(this._channel,[Fe.Occupancy],l)):this._unsubscribeOccupancyEvents=()=>{}}subscribe(e){if(this._logger.trace("Occupancy.subscribe();"),!this._roomOptions.occupancy.enableEvents)throw new g.ErrorInfo("cannot subscribe to occupancy; occupancy events are not enabled in room options",4e4,400);const t=T(e);return this._emitter.on(t),{unsubscribe:()=>{this._logger.trace("Occupancy.unsubscribe();"),this._emitter.off(t)}}}async get(){return this._logger.trace("Occupancy.get();"),this._chatApi.getOccupancy(this._roomName)}current(){if(this._logger.trace("Occupancy.current();"),!this._roomOptions.occupancy.enableEvents)throw new g.ErrorInfo("cannot get current occupancy; occupancy events are not enabled in room options",4e4,400);return this._latestOccupancyData}_internalOccupancyListener(e){this._logger.trace("Occupancy._internalOccupancyListener();",e),this._latestOccupancyData=cs(e),this._emitter.emit(ne.Updated,{type:ne.Updated,occupancy:this._latestOccupancyData})}static channelOptionMerger(e){return t=>e.occupancy.enableEvents?{...t,params:{...t.params,occupancy:"metrics"}}:t}dispose(){this._logger.trace("DefaultOccupancy.dispose();"),this._unsubscribeOccupancyEvents(),this._emitter.off(),this._logger.debug("DefaultOccupancy.dispose(); disposed successfully")}hasListeners(){return L(this._emitter)}}class Qe{constructor(e,t,r,i){this._emitter=new C,this._stateEmitter=new C,this._presenceState={present:!1},this.subscribeToEvents=u=>{this._emitter.emit(u.action,{type:u.action,member:this._realtimeMemberToPresenceMember(u)})},this._channel=e,this._clientId=t,this._logger=r,this._options=i;const c=this.subscribeToEvents.bind(this),l=u=>{u.reason?.code===91004&&(this._logger.debug("Presence auto-reentry failed",{reason:u.reason}),this._emitPresenceStateChange(!1,u.reason))};this._offChannelUpdate=k(this._channel,"update",l),this._unsubscribePresenceEvents=z(this._channel.presence,c)}async get(e){return this._logger.trace("Presence.get()",{params:e}),this._assertChannelState(),(await this._channel.presence.get(e)).map(r=>this._realtimeMemberToPresenceMember(r))}async isUserPresent(e){return this._logger.trace("Presence.isUserPresent()",{clientId:e}),this._assertChannelState(),(await this._channel.presence.get({clientId:e})).length>0}async enter(e){this._logger.trace("Presence.enter()",{data:e}),this._assertChannelState();try{await this._channel.presence.enterClient(this._clientId,e),this._emitPresenceStateChange(!0)}catch(t){throw this._emitPresenceStateChange(!1,t),t}}async update(e){this._logger.trace("Presence.update()",{data:e}),this._assertChannelState();try{await this._channel.presence.updateClient(this._clientId,e),this._emitPresenceStateChange(!0)}catch(t){throw this._emitPresenceStateChange(!1,t),t}}async leave(e){this._logger.trace("Presence.leave()",{data:e}),this._assertChannelState();try{await this._channel.presence.leaveClient(this._clientId,e),this._emitPresenceStateChange(!1)}catch(t){throw this._emitPresenceStateChange(!1,t),t}}subscribe(e,t){if(this._logger.trace("Presence.subscribe(); listenerOrEvents",{listenerOrEvents:e}),!this._options.presence.enableEvents)throw this._logger.error("could not subscribe to presence; presence events are not enabled"),new g.ErrorInfo("could not subscribe to presence; presence events are not enabled",4e4,400);if(!e&&!t)throw this._logger.error("could not subscribe to presence; invalid arguments"),new g.ErrorInfo("could not subscribe listener: invalid arguments",4e4,400);if(t){const r=T(t);return this._emitter.on(e,r),{unsubscribe:()=>{this._logger.trace("Presence.unsubscribe();",{events:e}),this._emitter.off(r)}}}else{const r=T(e);return this._emitter.on(r),{unsubscribe:()=>{this._logger.trace("Presence.unsubscribe();"),this._emitter.off(r)}}}}static channelOptionMerger(e){return t=>(t.modes.includes("PRESENCE")||t.modes.push("PRESENCE"),e.presence.enableEvents&&!t.modes.includes("PRESENCE_SUBSCRIBE")&&t.modes.push("PRESENCE_SUBSCRIBE"),t)}dispose(){this._logger.trace("DefaultPresence.dispose();"),this._emitter.off(),this._unsubscribePresenceEvents(),this._offChannelUpdate(),this._logger.debug("DefaultPresence.dispose(); disposed successfully")}hasListeners(){return L(this._emitter)}_realtimeMemberToPresenceMember(e){return{...e,data:e.data,updatedAt:new Date(e.timestamp)}}_assertChannelState(){if(this._channel.state!=="attaching"&&this._channel.state!=="attached")throw this._logger.error("could not perform presence operation; room is not attached"),new g.ErrorInfo("could not perform presence operation; room is not attached",4e4,400)}_emitPresenceStateChange(e,t){this._logger.trace("Presence._emitPresenceStateChange()",{present:e,error:t});const r={...this._presenceState};this._presenceState={present:e};const i={previous:r,current:this._presenceState,error:t};this._stateEmitter.emit("presence.state.change",i)}onPresenceStateChange(e){this._logger.trace("Presence.onPresenceStateChange()");const t=T(e);return this._stateEmitter.on("presence.state.change",t),{unsubscribe:()=>{this._logger.trace("Presence.unsubscribeFromPresenceStateChanges()"),this._stateEmitter.off(t)}}}}const ce=new Error("request for lock canceled");var hs=function(n,e,t,r){function i(c){return c instanceof t?c:new t(function(l){l(c)})}return new(t||(t=Promise))(function(c,l){function u(d){try{y(r.next(d))}catch(w){l(w)}}function _(d){try{y(r.throw(d))}catch(w){l(w)}}function y(d){d.done?c(d.value):i(d.value).then(u,_)}y((r=r.apply(n,e||[])).next())})};class ls{constructor(e,t=ce){this._value=e,this._cancelError=t,this._queue=[],this._weightedWaiters=[]}acquire(e=1,t=0){if(e<=0)throw new Error(`invalid weight ${e}: must be positive`);return new Promise((r,i)=>{const c={resolve:r,reject:i,weight:e,priority:t},l=Je(this._queue,u=>t<=u.priority);l===-1&&e<=this._value?this._dispatchItem(c):this._queue.splice(l+1,0,c)})}runExclusive(e){return hs(this,arguments,void 0,function*(t,r=1,i=0){const[c,l]=yield this.acquire(r,i);try{return yield t(c)}finally{l()}})}waitForUnlock(e=1,t=0){if(e<=0)throw new Error(`invalid weight ${e}: must be positive`);return this._couldLockImmediately(e,t)?Promise.resolve():new Promise(r=>{this._weightedWaiters[e-1]||(this._weightedWaiters[e-1]=[]),us(this._weightedWaiters[e-1],{resolve:r,priority:t})})}isLocked(){return this._value<=0}getValue(){return this._value}setValue(e){this._value=e,this._dispatchQueue()}release(e=1){if(e<=0)throw new Error(`invalid weight ${e}: must be positive`);this._value+=e,this._dispatchQueue()}cancel(){this._queue.forEach(e=>e.reject(this._cancelError)),this._queue=[]}_dispatchQueue(){for(this._drainUnlockWaiters();this._queue.length>0&&this._queue[0].weight<=this._value;)this._dispatchItem(this._queue.shift()),this._drainUnlockWaiters()}_dispatchItem(e){const t=this._value;this._value-=e.weight,e.resolve([t,this._newReleaser(e.weight)])}_newReleaser(e){let t=!1;return()=>{t||(t=!0,this.release(e))}}_drainUnlockWaiters(){if(this._queue.length===0)for(let e=this._value;e>0;e--){const t=this._weightedWaiters[e-1];t&&(t.forEach(r=>r.resolve()),this._weightedWaiters[e-1]=[])}else{const e=this._queue[0].priority;for(let t=this._value;t>0;t--){const r=this._weightedWaiters[t-1];if(!r)continue;const i=r.findIndex(c=>c.priority<=e);(i===-1?r:r.splice(0,i)).forEach(c=>c.resolve())}}}_couldLockImmediately(e,t){return(this._queue.length===0||this._queue[0].priority<t)&&e<=this._value}}function us(n,e){const t=Je(n,r=>e.priority<=r.priority);n.splice(t+1,0,e)}function Je(n,e){for(let t=n.length-1;t>=0;t--)if(e(n[t]))return t;return-1}var gs=function(n,e,t,r){function i(c){return c instanceof t?c:new t(function(l){l(c)})}return new(t||(t=Promise))(function(c,l){function u(d){try{y(r.next(d))}catch(w){l(w)}}function _(d){try{y(r.throw(d))}catch(w){l(w)}}function y(d){d.done?c(d.value):i(d.value).then(u,_)}y((r=r.apply(n,e||[])).next())})};class Xe{constructor(e){this._semaphore=new ls(1,e)}acquire(){return gs(this,arguments,void 0,function*(e=0){const[,t]=yield this._semaphore.acquire(1,e);return t})}runExclusive(e,t=0){return this._semaphore.runExclusive(()=>e(),1,t)}isLocked(){return this._semaphore.isLocked()}waitForUnlock(e=0){return this._semaphore.waitForUnlock(1,e)}release(){this._semaphore.isLocked()&&this._semaphore.release()}cancel(){return this._semaphore.cancel()}}var p=(n=>(n.Initializing="initializing",n.Initialized="initialized",n.Attaching="attaching",n.Attached="attached",n.Detaching="detaching",n.Detached="detached",n.Suspended="suspended",n.Failed="failed",n.Releasing="releasing",n.Released="released",n))(p||{});class ds{constructor(e){this._status="initialized",this._emitter=new C,this._logger=e}get status(){return this._status}get error(){return this._error}onChange(e){const t=T(e);return this._emitter.on(t),{off:()=>{this._emitter.off(t)}}}setStatus(e){const t={current:e.status,error:e.error,previous:this._status};this._status=t.current,this._error=t.error,this._logger.info("room status changed",{...t}),this._emitter.emit(t.current,t)}dispose(){this._logger.trace("DefaultRoomLifecycle.dispose();"),this._emitter.off(),this._logger.debug("DefaultRoomLifecycle.dispose(); disposed successfully")}hasListeners(){return L(this._emitter)}}class _s{constructor(e,t,r){this._channelManager=e,this._roomLifecycle=t,this._logger=r,this._eventEmitter=new C,this._hasAttachedOnce=!1,this._isExplicitlyDetached=!1,this._mutex=new Xe;const i=this._channelStateListener.bind(this),c=this._discontinuityOnAttachedListener.bind(this),l=this._discontinuityOnUpdateListener.bind(this),u=this._channelManager.get();this._unsubscribeChannelStateListener=k(u,i),this._offDiscontinuityAttached=k(u,"attached",c),this._offDiscontinuityUpdate=k(u,"update",l)}onDiscontinuity(e){this._logger.trace("RoomLifecycleManager.onDiscontinuity()");const t=T(e);return this._eventEmitter.on(H.Discontinuity,t),{off:()=>{this._eventEmitter.off(H.Discontinuity,t)}}}async attach(){await this._mutex.runExclusive(async()=>{if(this._logger.trace("RoomLifecycleManager.attach();"),this._checkRoomNotReleasing("attach"),this._roomStatusIs(p.Attached)){this._logger.debug("RoomLifecycleManager.attach(); room already attached, no-op");return}const e=this._channelManager.get();this._logger.debug("RoomLifecycleManager.attach(); attaching room",{channelState:e.state});try{this._setStatus(p.Attaching),await e.attach(),this._setStatus(p.Attached),this._isExplicitlyDetached=!1,this._hasAttachedOnce=!0,this._logger.debug("RoomLifecycleManager.attach(); room attached successfully")}catch(t){const r=t,i=new g.ErrorInfo(`failed to attach room: ${r.message}`,r.code,r.statusCode,r),c=this._mapChannelStateToRoomStatus(e.state);throw this._setStatus(c,i),i}},1)}async detach(){await this._mutex.runExclusive(async()=>{if(this._logger.trace("RoomLifecycleManager.detach();"),this._roomStatusIs(p.Failed))throw new g.ErrorInfo("cannot detach room, room is in failed state",U.RoomInFailedState,400);if(this._checkRoomNotReleasing("detach"),this._roomStatusIs(p.Detached)){this._logger.debug("RoomLifecycleManager.detach(); room already detached, no-op");return}const e=this._channelManager.get();this._logger.debug("RoomLifecycleManager.detach(); detaching room",{channelState:e.state});try{this._setStatus(p.Detaching),await e.detach(),this._isExplicitlyDetached=!0,this._setStatus(p.Detached),this._logger.debug("RoomLifecycleManager.detach(); room detached successfully")}catch(t){const r=t,i=new g.ErrorInfo(`failed to detach room: ${r.message}`,r.code,r.statusCode,r),c=this._mapChannelStateToRoomStatus(e.state);throw this._setStatus(c,i),i}},1)}async release(){await this._mutex.runExclusive(async()=>{if(this._logger.trace("RoomLifecycleManager.release();"),this._roomStatusIs(p.Released)){this._logger.debug("RoomLifecycleManager.release(); room already released, no-op");return}if(this._roomStatusIs(p.Initialized)||this._roomStatusIs(p.Detached)){this._logger.debug("RoomLifecycleManager.release(); room is initialized or detached, releasing immediately",{status:this._roomLifecycle.status}),this._releaseChannel();return}this._setStatus(p.Releasing);const e=this._channelManager.get();this._logger.debug("RoomLifecycleManager.release(); attempting channel detach before release",{channelState:e.state}),await this._channelDetachLoop(e),this._releaseChannel()},0)}_mapChannelStateToRoomStatus(e){switch(e){case"initialized":return p.Initialized;case"attaching":return p.Attaching;case"attached":return p.Attached;case"detaching":return p.Detaching;case"detached":return p.Detached;case"suspended":return p.Suspended;case"failed":return p.Failed;default:return this._logger.error("RoomLifecycleManager._mapChannelStateToRoomStatus(); unknown channel state",{channelState:e}),p.Failed}}_checkRoomNotReleasing(e){switch(this._roomLifecycle.status){case p.Released:throw new g.ErrorInfo(`cannot ${e} room, room is released`,U.RoomIsReleased,400);case p.Releasing:throw new g.ErrorInfo(`cannot ${e} room, room is currently releasing`,U.RoomIsReleasing,400)}}_roomStatusIs(e){return this._roomLifecycle.status===e}dispose(){this._unsubscribeChannelStateListener(),this._offDiscontinuityAttached(),this._offDiscontinuityUpdate(),this._eventEmitter.off()}hasListeners(){return L(this._eventEmitter)}_channelStateListener(e){if(this._logger.debug("RoomLifecycleManager.channel state changed",{oldState:e.previous,newState:e.current,reason:e.reason,resumed:e.resumed}),this._operationInProgress()){this._logger.debug("RoomLifecycleManager._startMonitoringChannelState(); ignoring channel state change - operation in progress",{status:this._roomLifecycle.status});return}const t=this._mapChannelStateToRoomStatus(e.current);this._setStatus(t,e.reason)}_discontinuityOnAttachedListener(e){if(!e.resumed&&this._hasAttachedOnce&&!this._isExplicitlyDetached){const t=new g.ErrorInfo("discontinuity detected",U.RoomDiscontinuity,e.reason?.statusCode??0,e.reason);this._logger.warn("RoomLifecycleManager._startMonitoringDiscontinuity(); discontinuity detected",{error:t}),this._eventEmitter.emit(H.Discontinuity,t)}}_discontinuityOnUpdateListener(e){if(!e.resumed&&this._hasAttachedOnce&&!this._isExplicitlyDetached&&e.current==="attached"&&e.previous==="attached"){const t=new g.ErrorInfo("discontinuity detected",U.RoomDiscontinuity,e.reason?.statusCode??0,e.reason);this._logger.warn("RoomLifecycleManager._startMonitoringDiscontinuity(); discontinuity detected",{error:t}),this._eventEmitter.emit(H.Discontinuity,t)}}async _channelDetachLoop(e){for(;;){if(e.state==="failed"){this._logger.debug("RoomLifecycleManager._channelDetachLoop(); channel is failed, skipping detach");break}try{await e.detach();break}catch(r){this._logger.error("RoomLifecycleManager._channelDetachLoop(); failed to detach channel during release",{error:r}),await new Promise(i=>setTimeout(i,250))}}}_setStatus(e,t){this._logger.debug("RoomLifecycleManager._setStatus(); updating room status",{oldStatus:this._roomLifecycle.status,newStatus:e,hasError:!!t}),this._roomLifecycle.setStatus({status:e,error:t})}_releaseChannel(){this._channelManager.release(),this._setStatus(p.Released),this._logger.debug("RoomLifecycleManager._releaseChannel(); room released successfully")}_operationInProgress(){return this._mutex.isLocked()}testForceHasAttachedOnce(e){this._logger.trace("RoomLifecycleManager.testForceHasAttachedOnce();",{firstAttach:e}),this._hasAttachedOnce=e}}const he={typing:{heartbeatThrottleMs:1e4},occupancy:{enableEvents:!1},presence:{enableEvents:!0},messages:{rawMessageReactions:!1,defaultMessageReactionType:x.Distinct}},fs=n=>new g.ErrorInfo(`invalid room configuration: ${n}`,40001,400),ps=n=>{ms(n.typing)},ms=n=>{if(n.heartbeatThrottleMs<=0)throw fs("typing heartbeat interval must be greater than 0")},ys=n=>({...he.typing,...n?.typing}),bs=n=>({...he.occupancy,...n?.occupancy}),ws=n=>({...he.presence,...n?.presence}),Ss=n=>({...he.messages,...n?.messages}),vs=(n,e)=>({typing:ys(n),occupancy:bs(n),presence:ws(n),messages:Ss(n),isReactClient:e}),Ye=(n,e)=>({name:n,data:e,extras:{ephemeral:!0}}),Rs=n=>{const e=n.extras?n.extras:{};return{...n,extras:{...e,ephemeral:!0}}};class Ts{constructor(e,t,r,i,c,l){this.name=e,this.clientId=t,this.createdAt=r,this.isSelf=i,this.metadata=c,this.headers=l,Object.freeze(this)}}const Ms=(n,e)=>{const t=n,r=t.data?.name&&typeof t.data.name=="string"?t.data.name:"",i=t.clientId??"",c=t.timestamp?new Date(t.timestamp):new Date;return new Ts(r,i,c,e?e===i:!1,t.data?.metadata??{},t.extras?.headers??{})};class As{constructor(e,t,r,i){this._emitter=new C,this._forwarder=l=>{const u=Ms(l,this._clientId);this._emitter.emit(ve.Reaction,{type:ve.Reaction,reaction:u})},this._channel=e,this._connection=t,this._clientId=r,this._logger=i;const c=this._forwarder.bind(this);this._unsubscribeRoomReactionEvents=z(this._channel,[Se.Reaction],c)}send(e){this._logger.trace("RoomReactions.send();",e);const{name:t,metadata:r,headers:i}=e;if(!t)return Promise.reject(new g.ErrorInfo("unable to send reaction; name not set and it is required",40001,400));if(this._connection.state!=="connected")return Promise.reject(new g.ErrorInfo("unable to send reaction; not connected to Ably",4e4,400));const c={name:t,metadata:r??{}},l={name:Se.Reaction,data:c,extras:{headers:i??{}}};return this._channel.publish(Rs(l))}subscribe(e){this._logger.trace("RoomReactions.subscribe();");const t=T(e);return this._emitter.on(t),{unsubscribe:()=>{this._logger.trace("RoomReactions.unsubscribe();"),this._emitter.off(t)}}}dispose(){this._unsubscribeRoomReactionEvents(),this._emitter.off()}hasListeners(){return L(this._emitter)}}class Cs extends C{constructor(e,t,r,i,c){super(),this._timeoutMs=2e3,this._mutex=new Xe,this._internalSubscribeToEvents=l=>{const{name:u,clientId:_}=l;if(this._logger.trace("DefaultTyping._internalSubscribeToEvents(); received event",{name:u,clientId:_}),!_){this._logger.error("DefaultTyping._internalSubscribeToEvents(); invalid clientId in received event",{inbound:l});return}u===M.Started||u===M.Stopped?this._updateCurrentlyTyping(_,u):this._logger.warn("DefaultTyping._internalSubscribeToEvents(); unrecognized event",{name:u})},this._clientId=i,this._channel=r,this._connection=t,this._heartbeatThrottleMs=e.heartbeatThrottleMs,this._currentlyTyping=new Map,this._logger=c,this._unsubscribeTypingEvents=z(this._channel,[M.Started,M.Stopped],this._internalSubscribeToEvents.bind(this))}_clearAllTypingStates(){this._logger.debug("DefaultTyping._clearAllTypingStates(); clearing all typing states"),this._clearHeartbeatTimer(),this._clearCurrentlyTyping()}_clearHeartbeatTimer(){this._logger.trace("DefaultTyping._clearHeartbeatTimer(); clearing heartbeat timer"),this._heartbeatTimerId&&(clearTimeout(this._heartbeatTimerId),this._heartbeatTimerId=void 0)}_clearCurrentlyTyping(){this._logger.trace("DefaultTyping._clearCurrentlyTyping(); clearing current store and timeouts");for(const[,e]of this._currentlyTyping.entries())clearTimeout(e);this._currentlyTyping.clear()}current(){return this._logger.trace("DefaultTyping.current();"),new Set(this._currentlyTyping.keys())}get channel(){return this._channel}_startHeartbeatTimer(){if(!this._heartbeatTimerId){this._logger.trace("DefaultTyping.startHeartbeatTimer();");const e=this._heartbeatTimerId=setTimeout(()=>{this._logger.debug("DefaultTyping.startHeartbeatTimer(); heartbeat timer expired"),e===this._heartbeatTimerId&&(this._heartbeatTimerId=void 0)},this._heartbeatThrottleMs)}}async keystroke(){this._logger.trace("DefaultTyping.keystroke();"),this._mutex.cancel();try{await this._mutex.acquire()}catch(e){if(e===ce){this._logger.debug("DefaultTyping.keystroke(); mutex was canceled by a later operation");return}throw new g.ErrorInfo("mutex acquisition failed",5e4,500)}try{if(this._connection.state!=="connected")throw this._logger.error("DefaultTyping.keystroke(); connection is not connected",{status:this._connection.state}),new g.ErrorInfo("cannot type, connection is not connected",4e4,400);if(this._heartbeatTimerId){this._logger.debug("DefaultTyping.keystroke(); no-op, already typing and heartbeat timer has not expired");return}await this._channel.publish(Ye(M.Started)),this._startHeartbeatTimer(),this._logger.trace("DefaultTyping.keystroke(); starting timers")}finally{this._logger.trace("DefaultTyping.keystroke(); releasing mutex"),this._mutex.release()}}async stop(){this._logger.trace("DefaultTyping.stop();"),this._mutex.cancel();try{await this._mutex.acquire()}catch(e){if(e===ce){this._logger.debug("DefaultTyping.stop(); mutex was canceled by a later operation");return}throw new g.ErrorInfo("mutex acquisition failed",5e4,500)}try{if(this._connection.state!=="connected")throw this._logger.error("DefaultTyping.stop(); connection is not connected",{status:this._connection.state}),new g.ErrorInfo("cannot stop typing, connection is not connected",4e4,400);if(!this._heartbeatTimerId){this._logger.debug("DefaultTyping.stop(); no-op, not currently typing");return}await this._channel.publish(Ye(M.Stopped)),this._logger.trace("DefaultTyping.stop(); clearing timers"),clearTimeout(this._heartbeatTimerId),this._heartbeatTimerId=void 0}finally{this._logger.trace("DefaultTyping.stop(); releasing mutex"),this._mutex.release()}}subscribe(e){this._logger.trace("DefaultTyping.subscribe();");const t=T(e);return this.on(t),{unsubscribe:()=>{this._logger.trace("DefaultTyping.unsubscribe();"),this.off(t)}}}async dispose(){for(this._logger.trace("DefaultTyping.dispose();");;)try{this._mutex.cancel(),await this._mutex.acquire();break}catch(e){if(e===ce)this._logger.debug("DefaultTyping.dispose(); mutex was canceled"),await new Promise(t=>setTimeout(t,200)),this._logger.debug("DefaultTyping.dispose(); retrying mutex acquisition");else{this._logger.error("DefaultTyping.dispose(); failed to acquire mutex; could not complete resource disposal",{error:e});return}}this._clearAllTypingStates(),this._unsubscribeTypingEvents(),this.off(),this._mutex.release()}_updateCurrentlyTyping(e,t){this._logger.trace("DefaultTyping._updateCurrentlyTyping();",{clientId:e,event:t}),t===M.Started?this._handleTypingStart(e):this._handleTypingStop(e)}_startNewClientInactivityTimer(e){this._logger.trace("DefaultTyping._startNewClientInactivityTimer(); starting new inactivity timer",{clientId:e});const t=setTimeout(()=>{if(this._logger.trace("DefaultTyping._startNewClientInactivityTimer(); client typing timeout expired",{clientId:e}),this._currentlyTyping.get(e)!==t){this._logger.debug("DefaultTyping._startNewClientInactivityTimer(); timeout already cleared; ignoring",{clientId:e});return}this._currentlyTyping.delete(e),this.emit(P.SetChanged,{type:P.SetChanged,currentlyTyping:new Set(this._currentlyTyping.keys()),change:{clientId:e,type:M.Stopped}})},this._heartbeatThrottleMs+this._timeoutMs);return t}_handleTypingStart(e){this._logger.debug("DefaultTyping._handleTypingStart();",{clientId:e});const t=this._startNewClientInactivityTimer(e),r=this._currentlyTyping.get(e);this._currentlyTyping.set(e,t),r?(this._logger.debug("DefaultTyping._handleTypingStart(); received heartbeat for currently typing client",{clientId:e}),clearTimeout(r)):(this._logger.debug("DefaultTyping._handleTypingStart(); new client started typing",{clientId:e}),this.emit(P.SetChanged,{type:P.SetChanged,currentlyTyping:new Set(this._currentlyTyping.keys()),change:{clientId:e,type:M.Started}}))}_handleTypingStop(e){const t=this._currentlyTyping.get(e);if(!t){this._logger.trace('DefaultTyping._handleTypingStop(); received "Stop" event for client not in currentlyTyping list',{clientId:e});return}this._logger.debug("DefaultTyping._handleTypingStop(); client stopped typing",{clientId:e}),clearTimeout(t),this._currentlyTyping.delete(e),this.emit(P.SetChanged,{type:P.SetChanged,currentlyTyping:new Set(this._currentlyTyping.keys()),change:{clientId:e,type:M.Stopped}})}get heartbeatThrottleMs(){return this._heartbeatThrottleMs}get hasHeartbeatTimer(){return!!this._heartbeatTimerId}}class Es{constructor(e,t,r,i,c,l){ps(r),this._nonce=t,this._logger=l.withContext({roomName:e,roomNonce:t}),this._logger.debug("Room();",{options:r}),this._name=e,this._options=r,this._chatApi=c,this._lifecycle=new ds(this._logger);const u=this._channelManager=this._getChannelManager(r,i,this._logger),_=u.get();this._messages=new Zt(e,r.messages,_,this._chatApi,i.auth.clientId,this._logger),this._presence=new Qe(_,i.auth.clientId,this._logger,r),this._typing=new Cs(r.typing,i.connection,_,i.auth.clientId,this._logger),this._reactions=new As(_,i.connection,i.auth.clientId,this._logger),this._occupancy=new Ke(e,_,this._chatApi,this._logger,r),this._lifecycleManager=new _s(u,this._lifecycle,this._logger);let y=!1;this._finalizer=async()=>{if(y){this._logger.debug("Room.finalizer(); already finalized");return}await this._lifecycleManager.release(),this._lifecycleManager.dispose(),this._messages.dispose(),this._presence.dispose(),this._reactions.dispose(),this._occupancy.dispose(),await this._typing.dispose(),this._lifecycle.dispose(),y=!0}}_getChannelManager(e,t,r){const i=new os(this._name,t,r,e.isReactClient);return i.mergeOptions(Ke.channelOptionMerger(e)),i.mergeOptions(Qe.channelOptionMerger(e)),i.mergeOptions(Ve.channelOptionMerger(e)),i}get name(){return this._name}options(){return N(this._options)}get messages(){return this._messages}get presence(){return this._presence}get reactions(){return this._reactions}get typing(){return this._typing}get occupancy(){return this._occupancy}get status(){return this._lifecycle.status}get error(){return this._lifecycle.error}onStatusChange(e){return this._lifecycle.onChange(e)}async attach(){return this._logger.trace("Room.attach();"),this._lifecycleManager.attach()}async detach(){return this._logger.trace("Room.detach();"),this._lifecycleManager.detach()}release(){return this._logger.trace("Room.release();"),this._finalizer()}get nonce(){return this._nonce}get lifecycle(){return this._lifecycle}get lifecycleManager(){return this._lifecycleManager}onDiscontinuity(e){return this._logger.trace("Room.onDiscontinuity();"),this._lifecycleManager.onDiscontinuity(e)}get channel(){return this._channelManager.get()}}class Is{constructor(e,t,r){this._rooms=new Map,this._releasing=new Map,this._isReact=!1,this._disposed=!1,this._realtime=e,this._chatApi=new es(e,r),this._clientOptions=t,this._logger=r}async get(e,t){this._logger.trace("Rooms.get();",{roomName:e}),this._ensureNotDisposed();const r=this._rooms.get(e);if(r)return this._handleExistingRoom(r,e,t);const i=this._releasing.get(e),c=ke();return i?this._waitForReleaseAndCreateRoom(e,c,t,i):this._createNewRoom(e,c,t)}async release(e){this._logger.trace("Rooms.release();",{roomName:e});const t=this._rooms.get(e),r=this._releasing.get(e);return t?r?this._handleConcurrentRelease(e,t,r):this._performRoomRelease(e,t):this._handleNonExistentRoomRelease(e,r)}async dispose(){this._logger.trace("Rooms.dispose();"),this._disposed=!0;const e=[...this._rooms.keys()];if(e.length===0){this._logger.debug("Rooms.dispose(); no rooms to release");return}const t=e.map(c=>this.release(c)),r=[...this._releasing.values()],i=[...t,...r];this._logger.debug("Rooms.dispose(); releasing rooms",{roomCount:e.length,roomNames:e}),await Promise.all(i),this._logger.debug("Rooms.dispose(); all rooms released successfully")}get clientOptions(){return this._clientOptions}get count(){return this._rooms.size}_ensureNotDisposed(){if(this._disposed)throw new g.ErrorInfo("cannot get room, rooms instance has been disposed",4e4,400)}async _handleExistingRoom(e,t,r){if(!X(e.options,r))throw new g.ErrorInfo("room already exists with different options",4e4,400);return this._logger.debug("Rooms.get(); returning existing room",{roomName:t,nonce:e.nonce,options:r}),await e.promise}_createNewRoom(e,t,r){const i=this._makeRoom(e,t,r),c={promise:Promise.resolve(i),nonce:t,options:r};return this._rooms.set(e,c),this._logger.debug("Rooms.get(); returning new room",{roomName:e,nonce:i.nonce}),i}async _waitForReleaseAndCreateRoom(e,t,r,i){const c=new AbortController,l=this._createAbortableRoomPromise(e,t,r,i,c);return this._rooms.set(e,{promise:l,options:r,nonce:t,abort:c}),this._logger.debug("Rooms.get(); creating new promise dependent on previous release",{roomName:e}),await l}_createAbortableRoomPromise(e,t,r,i,c){return new Promise((l,u)=>{const _=()=>{this._logger.debug("Rooms.get(); aborted before init",{roomName:e}),u(new g.ErrorInfo("room released before get operation could complete",U.RoomReleasedBeforeOperationCompleted,400))};c.signal.addEventListener("abort",_),i.then(()=>{if(c.signal.aborted){this._logger.debug("Rooms.get(); aborted before releasing promise resolved",{roomName:e});return}this._logger.debug("Rooms.get(); releasing finished",{roomName:e});const y=this._makeRoom(e,t,r);c.signal.removeEventListener("abort",_),l(y)}).catch(y=>{c.signal.removeEventListener("abort",_),u(y)})})}async _handleNonExistentRoomRelease(e,t){if(t){this._logger.debug("Rooms.release(); waiting for previous release call",{roomName:e}),await t;return}this._logger.debug("Rooms.release(); room does not exist",{roomName:e})}async _handleConcurrentRelease(e,t,r){t.abort&&(this._logger.debug("Rooms.release(); aborting get call",{roomName:e,existingNonce:t.nonce}),t.abort.abort(),this._rooms.delete(e)),await r}async _performRoomRelease(e,t){this._rooms.delete(e);const r=this._executeRoomRelease(e,t);this._releasing.set(e,r),this._logger.debug("Rooms.release(); creating new release promise",{roomName:e,nonce:t.nonce}),await r}async _executeRoomRelease(e,t){const r=await t.promise;this._logger.debug("Rooms.release(); releasing room",{roomName:e,nonce:t.nonce}),await r.release(),this._logger.debug("Rooms.release(); room released",{roomName:e,nonce:t.nonce}),this._releasing.delete(e)}_makeRoom(e,t,r){return new Es(e,t,vs(r,this._isReact),this._realtime,this._chatApi,this._logger)}useReact(){this._logger.trace("Rooms.useReact();"),this._isReact=!0}}class Os{constructor(e,t){this._realtime=e,this._clientOptions=$t(t),this._nonce=ke(),this._logger=zt(this._clientOptions).withContext({chatClientNonce:this._nonce}),this._connection=new Gt(e,this._logger),this._rooms=new Is(e,this._clientOptions,this._logger),this._addAgent("chat-js"),this._logger.trace(`ably chat client version ${oe}; initialized`)}get rooms(){return this._rooms}get connection(){return this._connection}get clientId(){return this._realtime.auth.clientId}get realtime(){return this._realtime}get clientOptions(){return this._clientOptions}get logger(){return this._logger}addReactAgent(){this._addAgent("chat-react"),this._rooms.useReact()}addAgentWithVersion(e,t){this._addAgent(e,t),this._logger.trace(`Added agent ${e} with version ${t}`)}async dispose(){this._logger.trace("ChatClient.dispose();"),await this._rooms.dispose(),this._connection.dispose(),this._logger.debug("ChatClient.dispose(); client disposed successfully")}_addAgent(e,t){const r=this._realtime;r.options.agents={...r.options.agents??r.options.agents,[e]:t??oe}}}m.ChatClient=Os,m.ChatMessageAction=R,m.ChatMessageEventType=E,m.ConnectionStatus=qe,m.ErrorCode=U,m.LogLevel=be,m.MessageReactionEventType=A,m.MessageReactionType=x,m.OccupancyEventType=ne,m.OrderBy=ae,m.PresenceEventType=He,m.RoomEventType=H,m.RoomStatus=p,m.TypingEventType=M,m.TypingSetEventType=P,m.errorInfoIs=ts,Object.defineProperty(m,Symbol.toStringTag,{value:"Module"})});
//# sourceMappingURL=ably-chat.umd.cjs.map
